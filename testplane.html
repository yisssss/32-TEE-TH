<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Plane</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: #e88470;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        .curtain {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 800px;
            height: 600px;
            cursor: pointer;
            z-index: 1;
        }

        video {
            width: 100%;
            height: 100%;
            display: block;
            opacity: 0;
        }

        .mode-buttons {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 2;
        }

        .mode-btn {
            padding: 10px 20px;
            font-size: 16px;
            background-color: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 2px solid #fff;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-btn:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        .mode-btn.active {
            background-color: #fff;
            color: #000;
        }

        .instruction {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 18px;
            text-align: center;
            z-index: 2;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <!-- Curtains.js WebGL canvas -->
    <div id="canvas"></div>

    <!-- Plane container -->
    <div class="curtain">
        <video id="main-video" data-sampler="uSampler0" crossorigin="" loop muted style="display: none;">
            <source src="assets/testvideo.mp4" type="video/mp4">
        </video>
        <img id="main-image" src="assets/testimg2.png" crossorigin="" data-sampler="uSampler0" alt="Test Image" style="display: none;">
        <img src="assets/clickimage.png" crossorigin="" data-sampler="uBiteTexture" alt="Bite Texture" style="display: none;">
    </div>

    <!-- Mode Toggle Buttons -->
    <div class="mode-buttons">
        <button id="btn-video" class="mode-btn active">1. Video</button>
        <button id="btn-image" class="mode-btn">2. Image</button>
    </div>

    <!-- Instruction -->
    <div class="instruction">
        Click and hold to see bite marks
    </div>

    <!-- Curtains.js import -->
    <script type="module">
        import { Curtains, Plane } from './curtainsjs/src/index.mjs';

        // ============================================
        // Mode Selection
        // ============================================
        let currentMode = 'video'; // 'video' or 'image'
        const btnVideo = document.getElementById('btn-video');
        const btnImage = document.getElementById('btn-image');
        const mainVideo = document.getElementById('main-video');
        const mainImage = document.getElementById('main-image');

        function switchMode(mode) {
            currentMode = mode;

            if (mode === 'video') {
                mainVideo.style.display = 'block';
                mainImage.style.display = 'none';
                btnVideo.classList.add('active');
                btnImage.classList.remove('active');
                if (mainVideo.paused) {
                    mainVideo.play().catch(err => {});
                }
            } else {
                mainVideo.style.display = 'none';
                mainImage.style.display = 'block';
                btnImage.classList.add('active');
                btnVideo.classList.remove('active');
            }
        }

        btnVideo.addEventListener('click', () => switchMode('video'));
        btnImage.addEventListener('click', () => switchMode('image'));

        // ============================================
        // Constants
        // ============================================
        const CONSTANTS = {
            MAX_BITES: 10,
            MIN_PRESS_DURATION: 60,
            MAX_PRESS_DURATION: 1500,
            MIN_PRESS_INTENSITY: 0.05,
            MAX_PRESS_INTENSITY: 0.7,

            // Main Plane Shader Uniforms
            MAIN_PLANE: {
                distortionStrength: 0.04,
                biteRadius: 0.2,
                blurRadius: 4.0,
                ringThickness: 0.8,
                dilation: 2.0,
                edgeSoftness: 0.8,
                highlightIntensity: 0.3,
                shadowIntensity: 0.5,
                lightSpread: 1.5,
            },
        };

        const MAX_BITES = CONSTANTS.MAX_BITES;
        const MIN_PRESS_DURATION = CONSTANTS.MIN_PRESS_DURATION;
        const MAX_PRESS_DURATION = CONSTANTS.MAX_PRESS_DURATION;
        const MIN_PRESS_INTENSITY = CONSTANTS.MIN_PRESS_INTENSITY;
        const MAX_PRESS_INTENSITY = CONSTANTS.MAX_PRESS_INTENSITY;

        // State variables
        let currentBiteIndex = 0;
        let biteCount = 0;
        let pressStartTime = 0;
        let currentPressIndex = -1;
        let isMouseDown = false;

        // Bite arrays
        const bitePositions = new Float32Array(MAX_BITES * 2);
        const biteIntensities = new Float32Array(MAX_BITES);
        const biteRotations = new Float32Array(MAX_BITES);

        // Load shaders
        let vs = '';
        let fs = '';

        // Load shader files
        console.log('Starting shader loading...');
        Promise.all([
            fetch('shaders/bitemark.vert').then(res => res.text()),
            fetch('shaders/bitemark.frag').then(res => res.text())
        ]).then(([vertexShader, fragmentShader]) => {
            vs = vertexShader;
            fs = fragmentShader;
            console.log('‚úÖ Shaders loaded successfully');
            console.log('Vertex shader length:', vs.length);
            console.log('Fragment shader length:', fs.length);
            initTestPlane();
        }).catch(err => {
            console.error('‚ùå Shader loading failed:', err);
            document.body.classList.add("no-curtains");
        });

        function initTestPlane() {
            console.log('üé¨ initTestPlane() called');

            // Initialize Curtains
            const curtains = new Curtains({
                container: "canvas",
                watchScroll: false,
                pixelRatio: Math.min(1.5, window.devicePixelRatio)
            });

            console.log('‚úÖ Curtains initialized:', curtains);

            // Error handling
            curtains.onError(() => {
                console.error('‚ùå Curtains error');
                document.body.classList.add("no-curtains");
            });

            // Get plane element
            const planeElement = document.querySelector('.curtain');
            const videoElement = planeElement.querySelector('video');

            // Plane parameters
            const params = {
                vertexShader: vs,
                fragmentShader: fs,
                widthSegments: 20,
                heightSegments: 20,
                samplers: [
                    {
                        name: "uSampler0",
                    },
                    {
                        name: "uBiteTexture",
                    }
                ],
                uniforms: {
                    resolution: {
                        name: "uResolution",
                        type: "2f",
                        value: [planeElement.clientWidth, planeElement.clientHeight],
                    },
                    time: {
                        name: "uTime",
                        type: "1f",
                        value: 0,
                    },
                    bitePositions: {
                        name: "uBitePositions",
                        type: "2fv",
                        value: new Float32Array(MAX_BITES * 2),
                    },
                    biteIntensities: {
                        name: "uBiteIntensities",
                        type: "1fv",
                        value: new Float32Array(MAX_BITES),
                    },
                    biteRotations: {
                        name: "uBiteRotations",
                        type: "1fv",
                        value: new Float32Array(MAX_BITES),
                    },
                    biteCount: {
                        name: "uBiteCount",
                        type: "1i",
                        value: 0,
                    },
                    distortionStrength: {
                        name: "uDistortionStrength",
                        type: "1f",
                        value: CONSTANTS.MAIN_PLANE.distortionStrength,
                    },
                    biteRadius: {
                        name: "uBiteRadius",
                        type: "1f",
                        value: CONSTANTS.MAIN_PLANE.biteRadius,
                    },
                    blurRadius: {
                        name: "uBlurRadius",
                        type: "1f",
                        value: CONSTANTS.MAIN_PLANE.blurRadius,
                    },
                    ringThickness: {
                        name: "uRingThickness",
                        type: "1f",
                        value: CONSTANTS.MAIN_PLANE.ringThickness,
                    },
                    dilation: {
                        name: "uDilation",
                        type: "1f",
                        value: CONSTANTS.MAIN_PLANE.dilation,
                    },
                    edgeSoftness: {
                        name: "uEdgeSoftness",
                        type: "1f",
                        value: CONSTANTS.MAIN_PLANE.edgeSoftness,
                    },
                    highlightIntensity: {
                        name: "uHighlightIntensity",
                        type: "1f",
                        value: CONSTANTS.MAIN_PLANE.highlightIntensity,
                    },
                    shadowIntensity: {
                        name: "uShadowIntensity",
                        type: "1f",
                        value: CONSTANTS.MAIN_PLANE.shadowIntensity,
                    },
                    lightSpread: {
                        name: "uLightSpread",
                        type: "1f",
                        value: CONSTANTS.MAIN_PLANE.lightSpread,
                    }
                }
            };

            // Create plane
            console.log('Creating plane with params:', params);
            const testPlane = new Plane(curtains, planeElement, params);
            console.log('‚úÖ Plane created:', testPlane);

            // Plane ready
            testPlane.onReady(() => {
                console.log('üé¨ Plane Ready event fired');
                testPlane.setPerspective(35);

                // Play video
                if (videoElement && videoElement.paused) {
                    videoElement.play().catch(err => {
                        console.error('Video play error:', err);
                    });
                }
                console.log('‚úÖ Plane setup complete');

                // Update bite intensity
                function updateBiteIntensity(plane, index, pressDuration) {
                    if (index < 0 || index >= MAX_BITES) return;

                    const normalized = Math.max(0, Math.min(1,
                        (pressDuration - MIN_PRESS_DURATION) / (MAX_PRESS_DURATION - MIN_PRESS_DURATION)
                    ));

                    const newIntensity = MIN_PRESS_INTENSITY +
                        (MAX_PRESS_INTENSITY - MIN_PRESS_INTENSITY) * normalized;

                    if (Math.abs(biteIntensities[index] - newIntensity) > 0.01) {
                        biteIntensities[index] = newIntensity;
                        plane.uniforms.biteIntensities.value = biteIntensities;
                    }
                }

                // Mouse down event
                function handleMouseDown(e) {
                    console.log('üñ±Ô∏è Mouse down event fired');
                    let clientX, clientY;

                    if (e.targetTouches) {
                        clientX = e.targetTouches[0].clientX;
                        clientY = e.targetTouches[0].clientY;
                    } else {
                        clientX = e.clientX;
                        clientY = e.clientY;
                    }

                    // Get plane position and size
                    const rect = planeElement.getBoundingClientRect();
                    console.log('Plane rect:', rect);
                    console.log('Click position:', { clientX, clientY });

                    // Check if click is outside plane
                    if (clientX < rect.left || clientX > rect.right ||
                        clientY < rect.top || clientY > rect.bottom) {
                        console.log('‚ùå Click outside plane, ignoring');
                        return;
                    }

                    console.log('‚úÖ Click inside plane');

                    // Calculate relative coordinates (0~1)
                    const relativeX = (clientX - rect.left) / rect.width;
                    const relativeY = (clientY - rect.top) / rect.height;

                    isMouseDown = true;
                    pressStartTime = Date.now();

                    // Calculate UV coordinates (Y-axis inverted)
                    const uvX = relativeX;
                    const uvY = 1.0 - relativeY;

                    // Set values at current index
                    const idx = currentBiteIndex % MAX_BITES;

                    bitePositions[idx * 2] = uvX;
                    bitePositions[idx * 2 + 1] = uvY;
                    biteIntensities[idx] = MIN_PRESS_INTENSITY;
                    biteRotations[idx] = Math.random() * Math.PI * 2;

                    if (biteCount < MAX_BITES) biteCount++;
                    currentPressIndex = idx;
                    currentBiteIndex++;

                    console.log('ü¶∑ New bite created:', {
                        index: idx,
                        position: [uvX, uvY],
                        intensity: MIN_PRESS_INTENSITY,
                        biteCount: biteCount
                    });

                    // Update uniforms
                    testPlane.uniforms.bitePositions.value = bitePositions;
                    testPlane.uniforms.biteIntensities.value = biteIntensities;
                    testPlane.uniforms.biteRotations.value = biteRotations;
                    testPlane.uniforms.biteCount.value = biteCount;

                    console.log('üìä Uniforms updated:', {
                        biteCount: testPlane.uniforms.biteCount.value,
                        biteIntensities: Array.from(biteIntensities.slice(0, biteCount))
                    });
                }

                // Mouse up event
                function handleMouseUp(e) {
                    if (!isMouseDown) return;

                    isMouseDown = false;
                    const pressDuration = Date.now() - pressStartTime;

                    // Update final intensity
                    updateBiteIntensity(testPlane, currentPressIndex, pressDuration);

                    currentPressIndex = -1;
                }

                // Register event listeners
                document.addEventListener("mousedown", handleMouseDown);
                document.addEventListener("mouseup", handleMouseUp);
                document.addEventListener("touchstart", handleMouseDown);
                document.addEventListener("touchend", handleMouseUp);

            }).onRender(() => {
                // Update time
                testPlane.uniforms.time.value++;

                // Debug: Log textures on first render
                if (testPlane.uniforms.time.value === 1) {
                    console.log('üìã All uniforms:', Object.keys(testPlane.uniforms));
                    console.log('üñºÔ∏è uSampler0 (video):', testPlane.uniforms.uSampler0);
                    console.log('üñºÔ∏è uBiteTexture:', testPlane.uniforms.uBiteTexture);
                }

                // Update intensity in real-time while mouse is down
                if (isMouseDown && currentPressIndex >= 0) {
                    const pressDuration = Date.now() - pressStartTime;

                    const normalized = Math.max(0, Math.min(1,
                        (pressDuration - MIN_PRESS_DURATION) / (MAX_PRESS_DURATION - MIN_PRESS_DURATION)
                    ));

                    const newIntensity = MIN_PRESS_INTENSITY +
                        (MAX_PRESS_INTENSITY - MIN_PRESS_INTENSITY) * normalized;

                    biteIntensities[currentPressIndex] = newIntensity;
                    testPlane.uniforms.biteIntensities.value = biteIntensities;
                }

            }).onAfterResize(() => {
                // Update resolution on resize
                const planeBoundingRect = testPlane.getBoundingRect();
                testPlane.uniforms.resolution.value = [planeBoundingRect.width, planeBoundingRect.height];
            }).onError(() => {
                document.body.classList.add("no-curtains");
            });
        }
    </script>
</body>
</html>
